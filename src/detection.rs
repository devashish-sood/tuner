// Old pitch detection code. Basic FFT and Harmonic Product Spectrum application. Decided to use the pitch-detection library since HPS does not handle noise generated by instruments well. 

// use rustfft::{num_complex::Complex, FftPlanner};
// use crate::fsvec::FixedSizeVec;


// const CONCERT_PITCH: f32 = 440.0;
// const NOTES: [&str; 12] = ["A", "A#", "B", "C", "C#", "D", "D#", "E", "F", "F#", "G", "G#"];

// pub struct PitchDetector {
//   last_pitch: Option<f32>,
//   buf: FixedSizeVec<f32>,
// }

// impl PitchDetector {
//   pub fn new(buf: FixedSizeVec<f32>) -> Self {
//     Self {
//       last_pitch: None, 
//       buf,
//     }
//   }

//   pub fn update(&mut self, new_data: &[f32]) {
//     self.buf.extend(new_data);
//   }

//   pub fn detect_pitch(&mut self) {
//     if !self.buf.full() {
//       return
//     }
//     let fft = self.apply_fft();
//     let freq_mag_pairs = self.construct_hps(&fft);
//     println!("{}", &freq_mag_pairs[0].0);
//     let new_pitch = self.find_pitch(&freq_mag_pairs[0].0);
//     println!("old {}", &self.last_pitch.unwrap_or(0.0));
//     println!("new {}", &new_pitch);
//     if self.last_pitch.is_none() || (f32::abs(self.last_pitch.clone().unwrap_or(new_pitch) - new_pitch) > 25.0 && new_pitch > 72.0) {
//       self.last_pitch = Some(new_pitch.clone());
//     }
//     let note = self.find_note(&self.last_pitch.unwrap_or(83.0));
//     println!("{}", note);
//   }

//   fn apply_fft(&self) -> Vec<Complex<f32>> {
//     let mut datapoints = self.buf.as_slice().iter().map(|&x| Complex::new(x, 0.0)).collect::<Vec<_>>();
//     let sample_rate = datapoints.len();
//     let mut planner = FftPlanner::<f32>::new();
//     let fft = planner.plan_fft_forward(sample_rate);
//     fft.process(&mut datapoints);
//     datapoints
//   }

//   fn construct_hps(&self, datapoints: &[Complex<f32>]) -> Vec<(f32, f32)> {
//     let mut hps = vec![0.0; datapoints.len() / 2];

//     for harmonic in 1..=4 {
//         for i in 0..hps.len() {
//             if i * harmonic < datapoints.len() / 2 {
//                 hps[i] += datapoints[i * harmonic].norm();
//             }
//         }
//       }
  
//       let mut freq_mag_pairs: Vec<(f32, f32)> = hps.iter().enumerate()
//       .map(|(i, &mag)| {
//           (i as f32, mag)
//       })
//       .collect();
  
//     freq_mag_pairs.sort_by(|a, b| b.1.partial_cmp(&a.1).unwrap());
//       for (frequency, magnitude) in freq_mag_pairs.clone().into_iter().take(10) {
//           println!("Frequency: {}, Magnitude: {}", frequency, magnitude);
//       }
//       freq_mag_pairs
//   }

//   fn find_half_steps(&self, freq: &f32) -> i32 {
//     let i = ((freq / CONCERT_PITCH).log2() * 12.0 + EPSILON).round() as i32;
//     i
//   }

//   fn find_pitch(&self, freq: &f32) -> f32 {
//     let i = self.find_half_steps(freq);
//     println!("half steps in pitch finder now {}", i);
//     let closest_pitch = CONCERT_PITCH * (2f32.powf(i as f32 / 12.0));
//     println!("pitching being returned {}", closest_pitch);
//     closest_pitch 
//   }

//   fn find_note(&self, freq: &f32) -> String {
//     let i = self.find_half_steps(freq);
//     println!("half steps in note {}, {}", freq, i);
//     let octave = 4 + (i - 3) / 12;
//     let closest_note = NOTES[(i % 12).abs() as usize];
//     let note_str = format!("{}{}", closest_note, octave);
//     note_str
//   }
// }